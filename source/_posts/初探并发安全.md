---
title: 初探并发安全
date: 2025-06-23 00:47:21
tags:
---


### 在什么情况下会出现并发安全问题

多线程之间如果需要访问共享变量，比如读写某一个变量，某一行数据库数据，访问临界资源等等，就可能出现并发安全问题，比如超卖，更新丢失，数据结构异常等等。这里说的并发安全其实说得是被访问的共享变量的安全，逻辑不符合预期

### 有什么方法解决并发安全问题

问题出在被访问变量上，所以我们可以使用安全的共享变量，比如原子类或者并发集合，比如`java`提供的原子整型`AtomicInteger`，可以保证自增自减操作是安全的，又比如并发集合类`ConcurrentHashMap`，可以保证访问和修改是安全的。这里还需要提到一个关键字`volatile`，对于它所修饰的变量，能够保证可见性，变量更新可以被立刻觉察

以上的安全变量，只能保证对它的单次操作是安全的，不会出现异常；但无法保证组合操作是安全的，也无法保证业务逻辑的安全，这时候就需要用到锁

锁能够保证被锁包裹的临界区只有一个线程访问，也就是线程间是串行执行，从而保证线程安全，业务逻辑的安全。`java`提供了比较多的锁，`synchronized`关键字，`Lock`接口及其实现类比如`ReentrantLock`，这些锁之间的区别在于重量级，能否重入，公平与否，能否被中断等等，但这些锁都会涉及操作系统的调度，都是比较重的锁；此外，`java`也提供了一些原子操作，可以实现更轻量的锁，比如`CAS`，`ComparedAndSwap`操作，实际上，前面提到的锁多多少少都会涉及到一些原子操作，如下我们可以使用`CAS`实现一个轻量的自旋锁，获取不到锁不会阻塞，会一直尝试获取锁
```java
public class CasLock {
    private final AtomicBoolean lock=new AtomicBoolean(false);
    public void lock(){
        while(!lock.compareAndSet(false,true))
    }
    public void unlock(){
        lock.set(false);
    }
}
```

### 怎么使用安全变量和锁

先要确定共享变量。如果没有共享变量，就不存在线程安全问题，共享变量一般是数据库的数据，或者是同一台主机内多线程共享的变量，比如某一个对象的属性
然后确定锁。锁也是共享的，与共享变量绑定，每个线程获取锁是互斥的，要确定不同线程申请的是同一把锁
最后包裹临界代码。临界代码就是访问共享变量和共享资源的代码